---
layout: mypost
title: "Java 异步任务处理"
excerpt: "简述 MX-UI.framwork 中 Task 异步处理的实现方法"
categories: [Java, 多线程, MX-UI]
---
*<font color="grey">
晚上经常选择性失眠，这篇文章就是几个晚上睡不着时作消遣的，估计逻辑会很乱的吧...其实文章的发布日期应该是 11/25 ， 24 日半夜写起的就索性写了 24 日的日期啦。<br />
正逢我今晚刚把 <a href="https://maxelblack.github.io/docs/mxui">MX-UI 框架</a> 的 Task 部分做完，所以就写了这么一篇文章，分享一下自己原创的一种异步任务处理方法。
</font>*

下面进入正题

## 为什么要异步执行任务

多数软件的 GUI 界面一般是单独运行在一个线程中的，而 Java 自带的 AWT 框架也是这样，然而 AWT 在执行事件监听器活动时仍然处于 GUI 界面的线程中。故一个事件监听器活动执行完毕之前， UI 是无法接受任何操作的，这就导致了在执行长时间任务时 UI 界面“卡住”的问题，轻则被系统判定无响应并强制结束丢失数据，重则直接使整个系统界面无响应，影响其他程序的执行安全。

那么如何解决这个时不时发生的问题呢？答案就是多线程异步处理任务。

## 多线程 Task 的实现思路

主要思路来自 [IntelliJ IDEA](https://www.jetbrains.com/idea) 这个著名的 Java IDE 。

如果用过，仔细体会一下 IDEA 的保存操作，再对比一些文本编辑器的保存，可能会发现 IDEA 在保存时根本不会让你感觉到它在保存，光标连个圈圈都没画（~~我刚开始用时有很多次认为它没执行保存这个操作，结果 Ctrl + S 快捷键点了又点也没有任何感觉~~）。如果不是发现原来空行的空格被自动去掉了，根本不会有人知道它执行了保存操作。

可能有经验的大佬马上就会脱口而出：这是多线程的应用效果。我的思路实际就是模仿 IDEA 的这个操作，在这基础上为了优化性能增加了可控制线程数量的依序执行方式。

## 主要类

- `Task`					任务对象
- `TaskManager`		任务执行的管理中心
- `TaskThread`		任务线程

**未完待续**
